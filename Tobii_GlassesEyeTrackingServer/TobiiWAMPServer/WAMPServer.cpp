#pragma once
#include "stdafx.h"
#include "WAMPServer.h"

TobiiEyeSample WAMPServer::currentSample;
WAMPServer::WAMPServer()
{
	closedManually = false;
	shouldLeave = false;
	StoppedUnexpectedly = false;
	bStopped = false;

	packageID = -1;
}


WAMPServer::~WAMPServer()
{
}

void WAMPServer::LeaveSession() {
	shouldLeave = true;
	closedManually = true;
}

int reconnection_attempts = 0;

bool WAMPServer::IsStoppedUnexpectedly()
{
	return StoppedUnexpectedly;
}

bool WAMPServer::IsStopped() {
	return bStopped;
}

void WAMPServer::WebsocketStreamer(string crossbarAddress, string _glassesID) {
	bool debug = false;
	std::string crossbarWSAddress = "ws://";
	crossbarWSAddress.append(crossbarAddress);
	crossbarWSAddress.append("/ws");
	glassesID = _glassesID;
	client ws_clinet;
	ws_clinet.init_asio(&io);
	auto transport_ed = std::make_shared < autobahn::wamp_websocketpp_websocket_transport<websocketpp::config::asio_client> >(
		ws_clinet, crossbarWSAddress, debug);

	// create a WAMP session that talks over websocket
	auto session_ed = std::make_shared<autobahn::wamp_session>(io, debug);
	transport_ed->attach(std::static_pointer_cast<autobahn::wamp_transport_handler>(session_ed));

	// Make sure the continuation futures we use do not run out of scope prematurely.
	// Since we are only using one thread here this can cause the io service to block
	// as a future generated by a continuation will block waiting for its promise to be
	// fulfilled when it goes out of scope. This would prevent the session from receiving
	// responses from the router.
	boost::future<void> connect_future;
	boost::future<void> start_future;
	boost::future<void> join_future;
	boost::future<void> leave_future_ed;
	boost::future<void> stop_future_ed;
	boost::future<void> call_future;

	connect_future = transport_ed->connect().then([&](boost::future<void> connected) {
		try {
			connected.get();
		}
		catch (const std::exception& e) {
			std::cerr << e.what() << std::endl;
			io.stop();
			return;
		}

		std::cerr << "transport connected" << std::endl;

		start_future = session_ed->start().then([&](boost::future<void> started) {
			try {
				started.get();
			}
			catch (const std::exception& e) {
				std::cerr << e.what() << std::endl;
				io.stop();
				return;
			}

			std::cerr << "Scene Camera session started" << std::endl;

			join_future = session_ed->join(std::string("hammlab")).then([&](boost::future<uint64_t> joined) {
				//Join the session, if it fails return
				try {
					std::cerr << "joined realm: " << joined.get() << std::endl;
				}
				catch (const std::exception& e) {
					std::cerr << e.what() << std::endl;
					io.stop();
					return;
				}

				/*call_future = session_ed->call("registerPublisher", std::tuple<std::string, std::array<std::string, 2>>(std::string("add"), std::array<std::string, 2>{glassesID, std::string("glasses")}))
					.then([&](boost::future<autobahn::wamp_call_result> result) {
					try {
						result.get();
					}
					catch (const std::exception& e) {
						std::cerr << "call failed: " << e.what() << std::endl;
						io.stop();
						return;
					}
				});*/

				//While we are running and the session is ok we stream samples
				while (!shouldLeave) {
					try {
						StreamGazeDataSample(session_ed);
						//SleepEx(10, FALSE);
					}
					catch (...) {
						std::exception_ptr eptr = std::current_exception();
					}
				}

				if (closedManually) {
					io.stop();
				}
			});
		});
	});

	std::cerr << "starting io service" << std::endl;
	io.run();
	std::cerr << "stopped io service" << std::endl;
	if (!closedManually) {
		StoppedUnexpectedly = true;
	}
	
	bStopped = true;
}

int counter = 0;

void WAMPServer::StreamGazeDataSample(std::shared_ptr<autobahn::wamp_session> session) {
	//Attempt to retrieve the next package from the DataContainer
	ptree package;
	bool sampleFetched = DataContainer::getInstance()->getGazeSample(package);

	//If the package was successfully retrieved we process it
	if (sampleFetched)
	{
		string status = package.get<string>("s"); //0 means everything is OK, if it is not zero means something went wrong
		string timestamp = package.get<string>("ts");

		if (package.get_optional<long>("gidx").has_value())
		{
			//Extract the sample id of the new sample
			long gazeIndex = package.get_optional<long>("gidx").value();

			//If this is our first package we set out packageID to this sample id
			if (packageID == -1) {
				packageID = gazeIndex;
			}
			//If the new sample id is smaller than the current sample we throw it away
			else if (gazeIndex < packageID) {
				printf("Old package recieved. Throwing away ID: %i \n", gazeIndex);
				return;
			}
			//If the new sample id is bigger than the current sample id we broadcast the current sample as it is finished
			else if(gazeIndex > packageID)
			{
				if (packageID != -1)
				{
					std::array<double, 16> data = { currentSample.left_confidence, currentSample.left_pupil_diameter / 2,
						currentSample.left_pupil_center[0], currentSample.left_pupil_center[1], currentSample.left_pupil_center[2],
						currentSample.left_gaze_direction[0], currentSample.left_gaze_direction[1], currentSample.left_gaze_direction[2],
						currentSample.right_confidence, currentSample.right_pupil_diameter / 2,
						currentSample.right_pupil_center[0], currentSample.right_pupil_center[1], currentSample.right_pupil_center[2],
						currentSample.right_gaze_direction[0], currentSample.right_gaze_direction[1], currentSample.right_gaze_direction[2]
					};

					msgpack::type::tuple<std::string, std::array<double, 16>> arguments =
						msgpack::type::make_tuple(glassesID, data);

					session->publish(std::string("EyeDataSample"), arguments);

					counter++;

					if (counter % 100 == 0) {
						printf("%i Eye Data packages published.\n", counter);
					}
					
					//std::cerr << "Eye Data published. ID: " << packageID << std::endl;

					//currentSample.timestamp = timestamp;
				}	

				currentSample = TobiiEyeSample();
				packageID = gazeIndex;
			}

			try { //check pupil center: pc
				std::array<double, 3> pupil_center;
				int count = 0;
				BOOST_FOREACH(boost::property_tree::ptree::value_type& rowPair, package.get_child("pc")) {
					pupil_center[count] = rowPair.second.get_value<double>();
					count++;
					if (count >= 3)
						break;
				}
				string eye = package.get<string>("eye");
				if (eye == "left")
				{
					currentSample.left_confidence = (status == "0") ? currentSample.left_confidence : -1;
					currentSample.left_pupil_center = pupil_center;
				}
				else
				{
					currentSample.right_confidence = (status == "0") ? currentSample.right_confidence : -1;
					currentSample.right_pupil_center = pupil_center;
				}
				return;
			}
			catch (boost::exception& be)
			{

			}

			try { //check pupil diameter: pd
				double pupil_diameter = package.get<double>("pd");
				string eye = package.get<string>("eye");
				if (eye == "left")
				{
					currentSample.left_confidence = (status == "0") ? currentSample.left_confidence : -1;
					currentSample.left_pupil_diameter = pupil_diameter;
				}
				else
				{
					currentSample.right_confidence = (status == "0") ? currentSample.right_confidence : -1;
					currentSample.right_pupil_diameter = pupil_diameter;
				}
				return;
			}
			catch (boost::exception& be)
			{

			}

			try { //check gaze direction: gd
				std::array<double, 3> gaze_direction;
				int count = 0;
				BOOST_FOREACH(boost::property_tree::ptree::value_type& rowPair, package.get_child("gd")) {
					gaze_direction[count] = rowPair.second.get_value<double>();
					count++;
					if (count >= 3)
						break;
				}
				string eye = package.get<string>("eye");
				if (eye == "left")
				{
					currentSample.left_confidence = (status == "0") ? currentSample.left_confidence : -1;
					currentSample.left_gaze_direction = gaze_direction;
				}
				else
				{
					currentSample.right_confidence = (status == "0") ? currentSample.right_confidence : -1;
					currentSample.right_gaze_direction = gaze_direction;
				}
				return;
			}
			catch (boost::exception& be)
			{

			}

			try { //check gaze position: gp
				std::array<double, 2> gaze_position;
				int count = 0;
				BOOST_FOREACH(boost::property_tree::ptree::value_type& rowPair, package.get_child("gp")) {
					gaze_position[count] = rowPair.second.get_value<double>();
					count++;
					if (count >= 2)
						break;
				}
				currentSample.gaze_position = gaze_position;
				return;
			}
			catch (boost::exception& be)
			{

			}

			try { //check gaze position 3d: gp3
				std::array<double, 3> gaze_position3d;
				int count = 0;
				BOOST_FOREACH(boost::property_tree::ptree::value_type& rowPair, package.get_child("gp3")) {
					gaze_position3d[count] = rowPair.second.get_value<double>();
					count++;
					if (count >= 3)
						break;
				}
				currentSample.gaze_position3d = gaze_position3d;
				return;
			}
			catch (boost::exception& be)
			{

			}
		}
	}
}